diff --git a/src/dynarec/arm64/arm64_next.S b/src/dynarec/arm64/arm64_next.S
index e900fbec..e9104b33 100644
--- a/src/dynarec/arm64/arm64_next.S
+++ b/src/dynarec/arm64/arm64_next.S
@@ -6,7 +6,13 @@
 .text
 .align 4
 
-.extern LinkNext
+#if defined(__APPLE__)
+#define LINKNEXT_SYMBOL _LinkNext
+#else
+#define LINKNEXT_SYMBOL LinkNext
+#endif
+
+.extern LINKNEXT_SYMBOL
 
 .global arm64_next
 
@@ -25,7 +31,7 @@ arm64_next:
     mov     x2, x30      // "from" is in lr, so put in x2
     add     x3, sp, 8*11    // x3 is address to change rip
     // call the function
-    bl      LinkNext
+    bl      LINKNEXT_SYMBOL
     // preserve return value
     mov     x3, x0
     // pop regs
diff --git a/src/dynarec/arm64/dynarec_arm64_arch.c b/src/dynarec/arm64/dynarec_arm64_arch.c
index 020d1d85..844a44af 100644
--- a/src/dynarec/arm64/dynarec_arm64_arch.c
+++ b/src/dynarec/arm64/dynarec_arm64_arch.c
@@ -300,6 +300,14 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
     }
     SUPER()
     #undef GO
+    uintptr_t native_pstate = 0;
+#if defined(__APPLE__)
+    if(p && p->uc_mcontext)
+        native_pstate = p->uc_mcontext->__ss.__cpsr;
+#else
+    native_pstate = p->uc_mcontext.pstate;
+#endif
+
     if(flags) {
         dynarec_log_prefix(0, LOG_INFO, " flags[%s-%s%s%s%s] ", flags->defered?"defered":"", flags->nf?"S":"", flags->vf?"O":"", flags->eq?"Z":"", flags->cf?(flags->inv_cf?"C(inv)":"C"):"");
         if(flags->defered) {
@@ -307,22 +315,32 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
             //return;
         }
         if(flags->nf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_N), F_SF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_N), F_SF);
         }
         if(flags->vf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_V), F_OF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_V), F_OF);
         }
         if(flags->eq) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_Z), F_ZF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_Z), F_ZF);
         }
         if(flags->cf) {
             if(flags->inv_cf) {
-                CONDITIONAL_SET_FLAG((p->uc_mcontext.pstate&(1<<NZCV_C))==0, F_CF);
+                CONDITIONAL_SET_FLAG((native_pstate&(1<<NZCV_C))==0, F_CF);
             } else {
-                CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_C), F_CF);
+                CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_C), F_CF);
             }
         }
     }
+#if defined(__APPLE__)
+    typedef struct fpsimd_context_s {
+        __uint128_t vregs[32];
+        uint32_t fpsr;
+        uint32_t fpcr;
+    } fpsimd_context_t;
+    fpsimd_context_t* fpsimd = NULL;
+    if(p && p->uc_mcontext)
+        fpsimd = (fpsimd_context_t*)&p->uc_mcontext->__ns;
+#else
     struct fpsimd_context *fpsimd = NULL;
     // find fpsimd struct
     {
@@ -334,6 +352,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
                 ff = (struct _aarch64_ctx*)((uintptr_t)ff + ff->size);
         }
     }
+#endif
     if(sse) {
         dynarec_log_prefix(0, LOG_INFO, " sse[%x (fpsimd=%p)] ", sse->sse, fpsimd);
         for(int i=0; i<16; ++i)
@@ -375,7 +394,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
         dynarec_log_prefix(0, LOG_INFO, " x87[%x, pos=%x, type=%x (fpsimd=%p)] ", x87->x87, x87->x87_pos, x87->x87_type, fpsimd);
         emu->top -= x87->delta;
         for(int i=0; i<8; ++i) {
-            if(x87->x87&(1<<i)) {
+            if(fpsimd && (x87->x87&(1<<i))) {
                 int idx = EMM0 + (x87->x87_pos>>(i*4))&0x0f;
                 int t = (x87->x87_type>>(i*2))&0x3;
                 switch (t) {
diff --git a/src/dynarec/dynablock.c b/src/dynarec/dynablock.c
index 517a702e..c4db83e3 100644
--- a/src/dynarec/dynablock.c
+++ b/src/dynarec/dynablock.c
@@ -180,7 +180,7 @@ dynablock_t *AddNewDynablock(uintptr_t addr)
 
 //TODO: move this to dynrec_arm.c and track allocated structure to avoid memory leak
 static __thread JUMPBUFF dynarec_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define DYN_JMPBUF dynarec_jmpbuf
 #else
 #define DYN_JMPBUF &dynarec_jmpbuf
diff --git a/src/dynarec/dynarec.c b/src/dynarec/dynarec.c
index ca0bd4f2..f6b16f1e 100644
--- a/src/dynarec/dynarec.c
+++ b/src/dynarec/dynarec.c
@@ -164,7 +164,7 @@ void DynaRun(x64emu_t* emu)
             emu->old_savedsp = emu->xSPSave;
             #endif
             emu->flags.jmpbuf_ready = 1;
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             if((skip=sigsetjmp(*(JUMPBUFF*)emu->jmpbuf, 1)))
             #else
             if((skip=sigsetjmp(emu->jmpbuf, 1)))
diff --git a/src/emu/x64emu_private.h b/src/emu/x64emu_private.h
index a9d73937..a6445074 100644
--- a/src/emu/x64emu_private.h
+++ b/src/emu/x64emu_private.h
@@ -51,7 +51,7 @@ typedef struct emu_flags_s {
     uint32_t    jmpbuf_ready:1;   // the jmpbuf in the emu is ok and don't need refresh
 } emu_flags_t;
 
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #include <setjmp.h>
 #define JUMPBUFF sigjmp_buf
 #else
diff --git a/src/emu/x86syscall.c b/src/emu/x86syscall.c
index 0ab60e4f..da20ee8a 100755
--- a/src/emu/x86syscall.c
+++ b/src/emu/x86syscall.c
@@ -11,7 +11,11 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
diff --git a/src/emu/x86syscall_32.c b/src/emu/x86syscall_32.c
index 31f07aad..d88d27e8 100644
--- a/src/emu/x86syscall_32.c
+++ b/src/emu/x86syscall_32.c
@@ -11,7 +11,11 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
diff --git a/src/libtools/signals.c b/src/libtools/signals.c
index 9b304e65..cc4137c8 100644
--- a/src/libtools/signals.c
+++ b/src/libtools/signals.c
@@ -284,7 +284,7 @@ uintptr_t getX64Address(dynablock_t* db, uintptr_t pc) {return 0;}
 
 // this allow handling "safe" function that just abort if accessing a bad address
 static __thread JUMPBUFF signal_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define SIG_JMPBUF signal_jmpbuf
 #else
 #define SIG_JMPBUF &signal_jmpbuf
@@ -1394,7 +1394,7 @@ void my_sigactionhandler_oldcode_64(x64emu_t* emu, int32_t sig, int simple, sigi
             #ifdef RV64
             emu->xSPSave = emu->old_savedsp;
             #endif
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             siglongjmp(*emu->jmpbuf, 1);
             #else
             siglongjmp(emu->jmpbuf, 1);
@@ -1683,7 +1683,7 @@ void my_box64signalhandler(int32_t sig, siginfo_t* info, void * ucntx)
                 if(Locks & is_dyndump_locked)
                     CancelBlock64(1);
                 emu->test.clean = 0;
-                #ifdef ANDROID
+                #if defined(ANDROID) || defined(__APPLE__)
                 siglongjmp(*(JUMPBUFF*)emu->jmpbuf, 2);
                 #else
                 siglongjmp(emu->jmpbuf, 2);
