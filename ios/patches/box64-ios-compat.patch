diff --git a/src/dynarec/arm64/arm64_next.S b/src/dynarec/arm64/arm64_next.S
index e900fbec..e9104b33 100644
--- a/src/dynarec/arm64/arm64_next.S
+++ b/src/dynarec/arm64/arm64_next.S
@@ -6,7 +6,13 @@
 .text
 .align 4
 
-.extern LinkNext
+#if defined(__APPLE__)
+#define LINKNEXT_SYMBOL _LinkNext
+#else
+#define LINKNEXT_SYMBOL LinkNext
+#endif
+
+.extern LINKNEXT_SYMBOL
 
 .global arm64_next
 
@@ -25,7 +31,7 @@ arm64_next:
     mov     x2, x30      // "from" is in lr, so put in x2
     add     x3, sp, 8*11    // x3 is address to change rip
     // call the function
-    bl      LinkNext
+    bl      LINKNEXT_SYMBOL
     // preserve return value
     mov     x3, x0
     // pop regs
diff --git a/src/dynarec/arm64/dynarec_arm64_arch.c b/src/dynarec/arm64/dynarec_arm64_arch.c
index 020d1d85..844a44af 100644
--- a/src/dynarec/arm64/dynarec_arm64_arch.c
+++ b/src/dynarec/arm64/dynarec_arm64_arch.c
@@ -300,6 +300,14 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
     }
     SUPER()
     #undef GO
+    uintptr_t native_pstate = 0;
+#if defined(__APPLE__)
+    if(p && p->uc_mcontext)
+        native_pstate = p->uc_mcontext->__ss.__cpsr;
+#else
+    native_pstate = p->uc_mcontext.pstate;
+#endif
+
     if(flags) {
         dynarec_log_prefix(0, LOG_INFO, " flags[%s-%s%s%s%s] ", flags->defered?"defered":"", flags->nf?"S":"", flags->vf?"O":"", flags->eq?"Z":"", flags->cf?(flags->inv_cf?"C(inv)":"C"):"");
         if(flags->defered) {
@@ -307,22 +315,32 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
             //return;
         }
         if(flags->nf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_N), F_SF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_N), F_SF);
         }
         if(flags->vf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_V), F_OF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_V), F_OF);
         }
         if(flags->eq) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_Z), F_ZF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_Z), F_ZF);
         }
         if(flags->cf) {
             if(flags->inv_cf) {
-                CONDITIONAL_SET_FLAG((p->uc_mcontext.pstate&(1<<NZCV_C))==0, F_CF);
+                CONDITIONAL_SET_FLAG((native_pstate&(1<<NZCV_C))==0, F_CF);
             } else {
-                CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_C), F_CF);
+                CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_C), F_CF);
             }
         }
     }
+#if defined(__APPLE__)
+    typedef struct fpsimd_context_s {
+        __uint128_t vregs[32];
+        uint32_t fpsr;
+        uint32_t fpcr;
+    } fpsimd_context_t;
+    fpsimd_context_t* fpsimd = NULL;
+    if(p && p->uc_mcontext)
+        fpsimd = (fpsimd_context_t*)&p->uc_mcontext->__ns;
+#else
     struct fpsimd_context *fpsimd = NULL;
     // find fpsimd struct
     {
@@ -334,6 +352,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
                 ff = (struct _aarch64_ctx*)((uintptr_t)ff + ff->size);
         }
     }
+#endif
     if(sse) {
         dynarec_log_prefix(0, LOG_INFO, " sse[%x (fpsimd=%p)] ", sse->sse, fpsimd);
         for(int i=0; i<16; ++i)
@@ -375,7 +394,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
         dynarec_log_prefix(0, LOG_INFO, " x87[%x, pos=%x, type=%x (fpsimd=%p)] ", x87->x87, x87->x87_pos, x87->x87_type, fpsimd);
         emu->top -= x87->delta;
         for(int i=0; i<8; ++i) {
-            if(x87->x87&(1<<i)) {
+            if(fpsimd && (x87->x87&(1<<i))) {
                 int idx = EMM0 + (x87->x87_pos>>(i*4))&0x0f;
                 int t = (x87->x87_type>>(i*2))&0x3;
                 switch (t) {
diff --git a/src/dynarec/dynablock.c b/src/dynarec/dynablock.c
index 517a702e..c4db83e3 100644
--- a/src/dynarec/dynablock.c
+++ b/src/dynarec/dynablock.c
@@ -180,7 +180,7 @@ dynablock_t *AddNewDynablock(uintptr_t addr)
 
 //TODO: move this to dynrec_arm.c and track allocated structure to avoid memory leak
 static __thread JUMPBUFF dynarec_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define DYN_JMPBUF dynarec_jmpbuf
 #else
 #define DYN_JMPBUF &dynarec_jmpbuf
diff --git a/src/dynarec/dynarec.c b/src/dynarec/dynarec.c
index ca0bd4f2..f6b16f1e 100644
--- a/src/dynarec/dynarec.c
+++ b/src/dynarec/dynarec.c
@@ -164,7 +164,7 @@ void DynaRun(x64emu_t* emu)
             emu->old_savedsp = emu->xSPSave;
             #endif
             emu->flags.jmpbuf_ready = 1;
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             if((skip=sigsetjmp(*(JUMPBUFF*)emu->jmpbuf, 1)))
             #else
             if((skip=sigsetjmp(emu->jmpbuf, 1)))
diff --git a/src/emu/x64emu_private.h b/src/emu/x64emu_private.h
index a9d73937..a6445074 100644
--- a/src/emu/x64emu_private.h
+++ b/src/emu/x64emu_private.h
@@ -51,7 +51,7 @@ typedef struct emu_flags_s {
     uint32_t    jmpbuf_ready:1;   // the jmpbuf in the emu is ok and don't need refresh
 } emu_flags_t;
 
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #include <setjmp.h>
 #define JUMPBUFF sigjmp_buf
 #else
diff --git a/src/emu/x64syscall.c b/src/emu/x64syscall.c
index 7cb4f934..74b35a44 100644
--- a/src/emu/x64syscall.c
+++ b/src/emu/x64syscall.c
@@ -1,3 +1,26 @@
+#if defined(__APPLE__)
+
+#include <errno.h>
+
+#include "debug.h"
+#include "x64emu.h"
+#include "x64emu_private.h"
+
+void EXPORT x64Syscall(x64emu_t *emu)
+{
+    (void)emu;
+    S_RAX = (uint64_t)-ENOSYS;
+}
+
+long EXPORT my_syscall(x64emu_t *emu)
+{
+    (void)emu;
+    errno = ENOSYS;
+    return -1;
+}
+
+#else
+
 #define _GNU_SOURCE         /* See feature_test_macros(7) */
 #include <stdint.h>
 #include <stdio.h>
@@ -1149,3 +1172,5 @@ long EXPORT my_syscall(x64emu_t *emu)
     }
     return 0;
 }
+
+#endif
diff --git a/src/emu/x86syscall.c b/src/emu/x86syscall.c
index 0ab60e4f..8baaa452 100755
--- a/src/emu/x86syscall.c
+++ b/src/emu/x86syscall.c
@@ -11,18 +11,23 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
 #include <sys/utsname.h>
-#ifndef __NR_socketcall
-#include <linux/net.h>
 #include <sys/socket.h>
-#endif
 #include <sys/resource.h>
 #include <poll.h>
 
+#if defined(__APPLE__)
+long syscall(long number, ...);
+#endif
+
 #include "debug.h"
 #include "box64stack.h"
 #include "x64emu.h"
@@ -141,7 +146,11 @@ static const scwrap_t syscallwrap[] = {
     //{ 211, __NR_getresgid32, 3 },
     //{ 220, __NR_getdents64, 3 },
     //{ 221, __NR_fcntl64, 3 },
+#ifdef __NR_gettid
     { 224, __NR_gettid, 0 },
+#else
+    { 0, -1, 0 },
+#endif
     //{ 240, __NR_futex, 6 },
     //{ 241, __NR_sched_setaffinity, 3 },
     //{ 242, __NR_sched_getaffinity, 3 },
@@ -237,6 +246,8 @@ void EXPORT x86Syscall(x64emu_t *emu)
     // check wrapper first
     int cnt = sizeof(syscallwrap) / sizeof(scwrap_t);
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
diff --git a/src/emu/x86syscall_32.c b/src/emu/x86syscall_32.c
index 31f07aad..0b4b40da 100644
--- a/src/emu/x86syscall_32.c
+++ b/src/emu/x86syscall_32.c
@@ -11,19 +11,24 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
 #include <sys/utsname.h>
-#ifndef __NR_socketcall
-#include <linux/net.h>
 #include <sys/socket.h>
-#endif
 #include <sys/resource.h>
 #include <poll.h>
 #include <linux/futex.h> 
 
+#if defined(__APPLE__)
+long syscall(long number, ...);
+#endif
+
 #include "debug.h"
 #include "box64stack.h"
 #include "x64emu.h"
@@ -129,7 +134,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 162, __NR_nanosleep, 2 },
     //{ 164, __NR_setresuid, 3 },
     //{ 168, __NR_poll, 3 },    // wrapped to allow SA_RESTART wrapping by libc
+    #ifdef __NR_prctl
     { 172, __NR_prctl, 5 },
+    #endif
     //{ 173, __NR_rt_sigreturn, 0 },
     //{ 175, __NR_rt_sigprocmask, 4 },
     //{ 179, __NR_rt_sigsuspend, 2 },
@@ -152,7 +159,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 211, __NR_getresgid32, 3 },
     //{ 220, __NR_getdents64, 3 },
     //{ 221, __NR_fcntl64, 3 },
+    #ifdef __NR_gettid
     { 224, __NR_gettid, 0 },
+    #endif
     //{ 240, __NR_futex, 6 },   // needs wrapping for the optionnal timespec part
     //{ 241, __NR_sched_setaffinity, 3 },
     //{ 242, __NR_sched_getaffinity, 3 },
@@ -163,7 +172,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 256, __NR_epoll_wait, 4 },
     //{ 265, __NR_clock_gettime, 2 },
     //{ 266, __NR_clock_getres, 2 },
+    #ifdef __NR_tgkill
     { 270, __NR_tgkill, 3 },
+    #endif
     //{ 271, __NR_utimes, 2 },
     //{ 291, __NR_inotify_init, 0},
     //{ 292, __NR_inotify_add_watch, 3},
@@ -178,6 +189,7 @@ static const scwrap_t syscallwrap[] = {
     //{ 355, __NR_getrandom, 3 },
     //{ 356, __NR_memfd_create, 2},
     //{ 449, __NR_futex_waitv, 5},
+    { 0, -1, 0 },
 };
 
 struct mmap_arg_struct {
@@ -301,6 +313,8 @@ void EXPORT x86Syscall(x64emu_t *emu)
     void* tmp;
     size_t tmps;
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
@@ -521,6 +535,8 @@ uint32_t EXPORT my32_syscall(x64emu_t *emu, uint32_t s, ptr_t* b)
     void* tmp;
     int ret;
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
diff --git a/src/include/myalign.h b/src/include/myalign.h
index 9b4ff512..47ef39b3 100644
--- a/src/include/myalign.h
+++ b/src/include/myalign.h
@@ -1,7 +1,11 @@
 #ifndef __MY_ALIGN__H_
 #define __MY_ALIGN__H_
 #include <stdint.h>
+#if defined(__APPLE__)
+#include <time.h>
+#else
 #include "bits/timespec.h"
+#endif
 #include "signal.h"
 
 typedef struct x64_va_list_s {
@@ -238,7 +242,7 @@ typedef struct jump_buff_x64_s {
 typedef struct __jmp_buf_tag_s {
     jump_buff_x64_t __jmpbuf;
     int              __mask_was_saved;
-    #ifdef ANDROID
+    #if defined(ANDROID) || defined(__APPLE__)
     sigset_t         __saved_mask;
     #else
     __sigset_t       __saved_mask;
diff --git a/src/libtools/signals.c b/src/libtools/signals.c
index 9b304e65..cc4137c8 100644
--- a/src/libtools/signals.c
+++ b/src/libtools/signals.c
@@ -284,7 +284,7 @@ uintptr_t getX64Address(dynablock_t* db, uintptr_t pc) {return 0;}
 
 // this allow handling "safe" function that just abort if accessing a bad address
 static __thread JUMPBUFF signal_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define SIG_JMPBUF signal_jmpbuf
 #else
 #define SIG_JMPBUF &signal_jmpbuf
@@ -1394,7 +1394,7 @@ void my_sigactionhandler_oldcode_64(x64emu_t* emu, int32_t sig, int simple, sigi
             #ifdef RV64
             emu->xSPSave = emu->old_savedsp;
             #endif
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             siglongjmp(*emu->jmpbuf, 1);
             #else
             siglongjmp(emu->jmpbuf, 1);
@@ -1683,7 +1683,7 @@ void my_box64signalhandler(int32_t sig, siginfo_t* info, void * ucntx)
                 if(Locks & is_dyndump_locked)
                     CancelBlock64(1);
                 emu->test.clean = 0;
-                #ifdef ANDROID
+                #if defined(ANDROID) || defined(__APPLE__)
                 siglongjmp(*(JUMPBUFF*)emu->jmpbuf, 2);
                 #else
                 siglongjmp(emu->jmpbuf, 2);
