diff --git a/src/dynarec/arm64/arm64_next.S b/src/dynarec/arm64/arm64_next.S
index e900fbec..e9104b33 100644
--- a/src/dynarec/arm64/arm64_next.S
+++ b/src/dynarec/arm64/arm64_next.S
@@ -6,7 +6,13 @@
 .text
 .align 4
 
-.extern LinkNext
+#if defined(__APPLE__)
+#define LINKNEXT_SYMBOL _LinkNext
+#else
+#define LINKNEXT_SYMBOL LinkNext
+#endif
+
+.extern LINKNEXT_SYMBOL
 
 .global arm64_next
 
@@ -25,7 +31,7 @@ arm64_next:
     mov     x2, x30      // "from" is in lr, so put in x2
     add     x3, sp, 8*11    // x3 is address to change rip
     // call the function
-    bl      LinkNext
+    bl      LINKNEXT_SYMBOL
     // preserve return value
     mov     x3, x0
     // pop regs
diff --git a/src/dynarec/arm64/dynarec_arm64_arch.c b/src/dynarec/arm64/dynarec_arm64_arch.c
index 020d1d85..844a44af 100644
--- a/src/dynarec/arm64/dynarec_arm64_arch.c
+++ b/src/dynarec/arm64/dynarec_arm64_arch.c
@@ -300,6 +300,14 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
     }
     SUPER()
     #undef GO
+    uintptr_t native_pstate = 0;
+#if defined(__APPLE__)
+    if(p && p->uc_mcontext)
+        native_pstate = p->uc_mcontext->__ss.__cpsr;
+#else
+    native_pstate = p->uc_mcontext.pstate;
+#endif
+
     if(flags) {
         dynarec_log_prefix(0, LOG_INFO, " flags[%s-%s%s%s%s] ", flags->defered?"defered":"", flags->nf?"S":"", flags->vf?"O":"", flags->eq?"Z":"", flags->cf?(flags->inv_cf?"C(inv)":"C"):"");
         if(flags->defered) {
@@ -307,22 +315,32 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
             //return;
         }
         if(flags->nf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_N), F_SF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_N), F_SF);
         }
         if(flags->vf) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_V), F_OF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_V), F_OF);
         }
         if(flags->eq) {
-            CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_Z), F_ZF);
+            CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_Z), F_ZF);
         }
         if(flags->cf) {
             if(flags->inv_cf) {
-                CONDITIONAL_SET_FLAG((p->uc_mcontext.pstate&(1<<NZCV_C))==0, F_CF);
+                CONDITIONAL_SET_FLAG((native_pstate&(1<<NZCV_C))==0, F_CF);
             } else {
-                CONDITIONAL_SET_FLAG(p->uc_mcontext.pstate&(1<<NZCV_C), F_CF);
+                CONDITIONAL_SET_FLAG(native_pstate&(1<<NZCV_C), F_CF);
             }
         }
     }
+#if defined(__APPLE__)
+    typedef struct fpsimd_context_s {
+        __uint128_t vregs[32];
+        uint32_t fpsr;
+        uint32_t fpcr;
+    } fpsimd_context_t;
+    fpsimd_context_t* fpsimd = NULL;
+    if(p && p->uc_mcontext)
+        fpsimd = (fpsimd_context_t*)&p->uc_mcontext->__ns;
+#else
     struct fpsimd_context *fpsimd = NULL;
     // find fpsimd struct
     {
@@ -334,6 +352,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
                 ff = (struct _aarch64_ctx*)((uintptr_t)ff + ff->size);
         }
     }
+#endif
     if(sse) {
         dynarec_log_prefix(0, LOG_INFO, " sse[%x (fpsimd=%p)] ", sse->sse, fpsimd);
         for(int i=0; i<16; ++i)
@@ -375,7 +394,7 @@ void adjust_arch(dynablock_t* db, x64emu_t* emu, ucontext_t* p, uintptr_t x64pc)
         dynarec_log_prefix(0, LOG_INFO, " x87[%x, pos=%x, type=%x (fpsimd=%p)] ", x87->x87, x87->x87_pos, x87->x87_type, fpsimd);
         emu->top -= x87->delta;
         for(int i=0; i<8; ++i) {
-            if(x87->x87&(1<<i)) {
+            if(fpsimd && (x87->x87&(1<<i))) {
                 int idx = EMM0 + (x87->x87_pos>>(i*4))&0x0f;
                 int t = (x87->x87_type>>(i*2))&0x3;
                 switch (t) {
diff --git a/src/dynarec/dynablock.c b/src/dynarec/dynablock.c
index 517a702e..c4db83e3 100644
--- a/src/dynarec/dynablock.c
+++ b/src/dynarec/dynablock.c
@@ -180,7 +180,7 @@ dynablock_t *AddNewDynablock(uintptr_t addr)
 
 //TODO: move this to dynrec_arm.c and track allocated structure to avoid memory leak
 static __thread JUMPBUFF dynarec_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define DYN_JMPBUF dynarec_jmpbuf
 #else
 #define DYN_JMPBUF &dynarec_jmpbuf
diff --git a/src/dynarec/dynarec.c b/src/dynarec/dynarec.c
index ca0bd4f2..f6b16f1e 100644
--- a/src/dynarec/dynarec.c
+++ b/src/dynarec/dynarec.c
@@ -164,7 +164,7 @@ void DynaRun(x64emu_t* emu)
             emu->old_savedsp = emu->xSPSave;
             #endif
             emu->flags.jmpbuf_ready = 1;
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             if((skip=sigsetjmp(*(JUMPBUFF*)emu->jmpbuf, 1)))
             #else
             if((skip=sigsetjmp(emu->jmpbuf, 1)))
diff --git a/src/emu/x64emu_private.h b/src/emu/x64emu_private.h
index a9d73937..a6445074 100644
--- a/src/emu/x64emu_private.h
+++ b/src/emu/x64emu_private.h
@@ -51,7 +51,7 @@ typedef struct emu_flags_s {
     uint32_t    jmpbuf_ready:1;   // the jmpbuf in the emu is ok and don't need refresh
 } emu_flags_t;
 
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #include <setjmp.h>
 #define JUMPBUFF sigjmp_buf
 #else
diff --git a/src/emu/x64run_private.c b/src/emu/x64run_private.c
index 4f3d5b4c..2aa26cf4 100644
--- a/src/emu/x64run_private.c
+++ b/src/emu/x64run_private.c
@@ -177,6 +177,15 @@ const char* GetNativeName(void* p)
         if(n)
             return n;
     }
+#if defined(__APPLE__)
+    {
+        const char *ret = GetNameOffset(my_context->maplib, p);
+        if(ret)
+            return ret;
+        sprintf(buff, "%s(%p)", "???", p);
+        return buff;
+    }
+#else
     Dl_info info;
     if(dladdr(p, &info)==0) {
         const char *ret = GetNameOffset(my_context->maplib, p);
@@ -196,6 +205,7 @@ const char* GetNativeName(void* p)
         }
     }
     return buff;
+#endif
 }
 void UpdateFlags(x64emu_t *emu)
 {
diff --git a/src/emu/x64syscall.c b/src/emu/x64syscall.c
index 7cb4f934..74b35a44 100644
--- a/src/emu/x64syscall.c
+++ b/src/emu/x64syscall.c
@@ -1,3 +1,26 @@
+#if defined(__APPLE__)
+
+#include <errno.h>
+
+#include "debug.h"
+#include "x64emu.h"
+#include "x64emu_private.h"
+
+void EXPORT x64Syscall(x64emu_t *emu)
+{
+    (void)emu;
+    S_RAX = (uint64_t)-ENOSYS;
+}
+
+long EXPORT my_syscall(x64emu_t *emu)
+{
+    (void)emu;
+    errno = ENOSYS;
+    return -1;
+}
+
+#else
+
 #define _GNU_SOURCE         /* See feature_test_macros(7) */
 #include <stdint.h>
 #include <stdio.h>
@@ -1149,3 +1172,5 @@ long EXPORT my_syscall(x64emu_t *emu)
     }
     return 0;
 }
+
+#endif
diff --git a/src/emu/x86syscall.c b/src/emu/x86syscall.c
index 0ab60e4f..7f8fe384 100755
--- a/src/emu/x86syscall.c
+++ b/src/emu/x86syscall.c
@@ -11,15 +11,16 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
 #include <sys/utsname.h>
-#ifndef __NR_socketcall
-#include <linux/net.h>
 #include <sys/socket.h>
-#endif
 #include <sys/resource.h>
 #include <poll.h>
 
@@ -141,7 +142,11 @@ static const scwrap_t syscallwrap[] = {
     //{ 211, __NR_getresgid32, 3 },
     //{ 220, __NR_getdents64, 3 },
     //{ 221, __NR_fcntl64, 3 },
+#ifdef __NR_gettid
     { 224, __NR_gettid, 0 },
+#else
+    { 0, -1, 0 },
+#endif
     //{ 240, __NR_futex, 6 },
     //{ 241, __NR_sched_setaffinity, 3 },
     //{ 242, __NR_sched_getaffinity, 3 },
@@ -237,6 +242,8 @@ void EXPORT x86Syscall(x64emu_t *emu)
     // check wrapper first
     int cnt = sizeof(syscallwrap) / sizeof(scwrap_t);
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
diff --git a/src/emu/x86syscall_32.c b/src/emu/x86syscall_32.c
index 31f07aad..0018d5b5 100644
--- a/src/emu/x86syscall_32.c
+++ b/src/emu/x86syscall_32.c
@@ -11,15 +11,16 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#if defined(__APPLE__)
+#include <sys/stat.h>
+#else
 #include <asm/stat.h>
+#endif
 #include <errno.h>
 #include <sched.h>
 #include <sys/wait.h>
 #include <sys/utsname.h>
-#ifndef __NR_socketcall
-#include <linux/net.h>
 #include <sys/socket.h>
-#endif
 #include <sys/resource.h>
 #include <poll.h>
 #include <linux/futex.h> 
@@ -129,7 +130,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 162, __NR_nanosleep, 2 },
     //{ 164, __NR_setresuid, 3 },
     //{ 168, __NR_poll, 3 },    // wrapped to allow SA_RESTART wrapping by libc
+    #ifdef __NR_prctl
     { 172, __NR_prctl, 5 },
+    #endif
     //{ 173, __NR_rt_sigreturn, 0 },
     //{ 175, __NR_rt_sigprocmask, 4 },
     //{ 179, __NR_rt_sigsuspend, 2 },
@@ -152,7 +155,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 211, __NR_getresgid32, 3 },
     //{ 220, __NR_getdents64, 3 },
     //{ 221, __NR_fcntl64, 3 },
+    #ifdef __NR_gettid
     { 224, __NR_gettid, 0 },
+    #endif
     //{ 240, __NR_futex, 6 },   // needs wrapping for the optionnal timespec part
     //{ 241, __NR_sched_setaffinity, 3 },
     //{ 242, __NR_sched_getaffinity, 3 },
@@ -163,7 +168,9 @@ static const scwrap_t syscallwrap[] = {
     //{ 256, __NR_epoll_wait, 4 },
     //{ 265, __NR_clock_gettime, 2 },
     //{ 266, __NR_clock_getres, 2 },
+    #ifdef __NR_tgkill
     { 270, __NR_tgkill, 3 },
+    #endif
     //{ 271, __NR_utimes, 2 },
     //{ 291, __NR_inotify_init, 0},
     //{ 292, __NR_inotify_add_watch, 3},
@@ -178,6 +185,7 @@ static const scwrap_t syscallwrap[] = {
     //{ 355, __NR_getrandom, 3 },
     //{ 356, __NR_memfd_create, 2},
     //{ 449, __NR_futex_waitv, 5},
+    { 0, -1, 0 },
 };
 
 struct mmap_arg_struct {
@@ -301,6 +309,8 @@ void EXPORT x86Syscall(x64emu_t *emu)
     void* tmp;
     size_t tmps;
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
@@ -521,6 +531,8 @@ uint32_t EXPORT my32_syscall(x64emu_t *emu, uint32_t s, ptr_t* b)
     void* tmp;
     int ret;
     for (int i=0; i<cnt; i++) {
+        if(syscallwrap[i].nats < 0)
+            continue;
         if(syscallwrap[i].x86s == s) {
             int sc = syscallwrap[i].nats;
             switch(syscallwrap[i].nbpars) {
diff --git a/src/include/myalign.h b/src/include/myalign.h
index 9b4ff512..ebfc97a3 100644
--- a/src/include/myalign.h
+++ b/src/include/myalign.h
@@ -1,7 +1,11 @@
 #ifndef __MY_ALIGN__H_
 #define __MY_ALIGN__H_
 #include <stdint.h>
+#if defined(__APPLE__)
+#include <time.h>
+#else
 #include "bits/timespec.h"
+#endif
 #include "signal.h"
 
 typedef struct x64_va_list_s {
@@ -54,6 +58,19 @@ typedef struct {
 
 #define PREFER_CONVERT_VAARG
 
+#elif defined(__aarch64__) && defined(__APPLE__)
+// Apple arm64 uses a pointer-style va_list layout that does not expose __gr_offs/__vr_offs.
+#define CREATE_SYSV_VALIST(A) \
+  va_list sysv_varargs = (va_list)(A);
+
+#define CONVERT_VALIST(A) \
+  va_list sysv_varargs = (va_list)((A)->overflow_arg_area);
+
+#define CREATE_VALIST_FROM_VAARG(STACK, SCRATCH, N) \
+  va_list sysv_varargs = (va_list)(STACK);
+
+#define PREFER_CONVERT_VAARG
+
 #elif defined(__aarch64__)
 // aarch64: 8 64bits general regs and 8 128bits float regs
 /*
@@ -238,7 +255,7 @@ typedef struct jump_buff_x64_s {
 typedef struct __jmp_buf_tag_s {
     jump_buff_x64_t __jmpbuf;
     int              __mask_was_saved;
-    #ifdef ANDROID
+    #if defined(ANDROID) || defined(__APPLE__)
     sigset_t         __saved_mask;
     #else
     __sigset_t       __saved_mask;
diff --git a/src/libtools/signals.c b/src/libtools/signals.c
index 9b304e65..cc4137c8 100644
--- a/src/libtools/signals.c
+++ b/src/libtools/signals.c
@@ -284,7 +284,7 @@ uintptr_t getX64Address(dynablock_t* db, uintptr_t pc) {return 0;}
 
 // this allow handling "safe" function that just abort if accessing a bad address
 static __thread JUMPBUFF signal_jmpbuf;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 #define SIG_JMPBUF signal_jmpbuf
 #else
 #define SIG_JMPBUF &signal_jmpbuf
@@ -1394,7 +1394,7 @@ void my_sigactionhandler_oldcode_64(x64emu_t* emu, int32_t sig, int simple, sigi
             #ifdef RV64
             emu->xSPSave = emu->old_savedsp;
             #endif
-            #ifdef ANDROID
+            #if defined(ANDROID) || defined(__APPLE__)
             siglongjmp(*emu->jmpbuf, 1);
             #else
             siglongjmp(emu->jmpbuf, 1);
@@ -1683,7 +1683,7 @@ void my_box64signalhandler(int32_t sig, siginfo_t* info, void * ucntx)
                 if(Locks & is_dyndump_locked)
                     CancelBlock64(1);
                 emu->test.clean = 0;
-                #ifdef ANDROID
+                #if defined(ANDROID) || defined(__APPLE__)
                 siglongjmp(*(JUMPBUFF*)emu->jmpbuf, 2);
                 #else
                 siglongjmp(emu->jmpbuf, 2);
diff --git a/src/wrapped/wrappedlibc.c b/src/wrapped/wrappedlibc.c
index 5771eb4e..e535b34f 100644
--- a/src/wrapped/wrappedlibc.c
+++ b/src/wrapped/wrappedlibc.c
@@ -546,7 +546,11 @@ pid_t EXPORT my_fork(x64emu_t* emu)
     return v;
     #endif
 }
+#if defined(__APPLE__)
+pid_t EXPORT my___fork(x64emu_t* emu) { return my_fork(emu); }
+#else
 pid_t EXPORT my___fork(x64emu_t* emu) __attribute__((alias("my_fork")));
+#endif
 pid_t EXPORT my_vfork(x64emu_t* emu)
 {
     #if 1
@@ -600,6 +604,21 @@ int EXPORT my_uname(struct utsname *buf)
 #ifndef FMODE_NONOTIFY
 #define FMODE_NONOTIFY 0x4000000
 #endif
+#ifndef O_RSYNC
+#define O_RSYNC 0
+#endif
+#ifndef O_DIRECT
+#define O_DIRECT 0
+#endif
+#ifndef O_LARGEFILE
+#define O_LARGEFILE 0
+#endif
+#ifndef O_NOATIME
+#define O_NOATIME 0
+#endif
+#ifndef O_PATH
+#define O_PATH 0
+#endif
 
 #define SUPER()     \
     GO(O_WRONLY)    \
@@ -665,9 +684,15 @@ EXPORT void my__ITM_memcpyRtWn(void * a, const void * b, size_t c) { (void)a; (v
 EXPORT void my__ITM_memcpyRnWt(void * a, const void * b, size_t c) { (void)a; (void)b; (void)c; printf("warning _ITM_memcpyRnWt called\n"); }
 
 EXPORT void my_longjmp(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p, int32_t __val);
+#if defined(__APPLE__)
+EXPORT void my__longjmp(x64emu_t* emu, void *p, int32_t __val) { my_longjmp(emu, p, __val); }
+EXPORT void my_siglongjmp(x64emu_t* emu, void *p, int32_t __val) { my_longjmp(emu, p, __val); }
+EXPORT void my___longjmp_chk(x64emu_t* emu, void *p, int32_t __val) { my_longjmp(emu, p, __val); }
+#else
 EXPORT void my__longjmp(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p, int32_t __val) __attribute__((alias("my_longjmp")));
 EXPORT void my_siglongjmp(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p, int32_t __val) __attribute__((alias("my_longjmp")));
 EXPORT void my___longjmp_chk(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p, int32_t __val) __attribute__((alias("my_longjmp")));
+#endif
 
 //EXPORT int32_t my_setjmp(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p);
 //EXPORT int32_t my__setjmp(x64emu_t* emu, /*struct __jmp_buf_tag __env[1]*/void *p) __attribute__((alias("my_setjmp")));
@@ -715,7 +740,11 @@ EXPORT int my_vprintf(x64emu_t *emu, void* fmt, x64_va_list_t b) {
     #endif
     return vprintf(fmt, VARARGS);
 }
+#if defined(__APPLE__)
+EXPORT int my___vprintf_chk(x64emu_t *emu, void* fmt, x64_va_list_t b) { return my_vprintf(emu, fmt, b); }
+#else
 EXPORT int my___vprintf_chk(x64emu_t *emu, void* fmt, x64_va_list_t b) __attribute__((alias("my_vprintf")));
+#endif
 
 EXPORT int my_vfprintf(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) {
     #ifdef CONVERT_VALIST
@@ -726,8 +755,13 @@ EXPORT int my_vfprintf(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) {
     #endif
     return vfprintf(F, fmt, VARARGS);
 }
+#if defined(__APPLE__)
+EXPORT int my___vfprintf_chk(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) { return my_vfprintf(emu, F, fmt, b); }
+EXPORT int my__IO_vfprintf(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) { return my_vfprintf(emu, F, fmt, b); }
+#else
 EXPORT int my___vfprintf_chk(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) __attribute__((alias("my_vfprintf")));
 EXPORT int my__IO_vfprintf(x64emu_t *emu, void* F, void* fmt, x64_va_list_t b) __attribute__((alias("my_vfprintf")));
+#endif
 
 EXPORT int my_fprintf(x64emu_t *emu, void* F, void* fmt, void* b)  {
     myStackAlign(emu, (const char*)fmt, b, emu->scratch, R_EAX, 2);
@@ -836,7 +870,11 @@ EXPORT int my_snprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, uint64_t
     int r = vsnprintf(buff, s, fmt, VARARGS);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my___snprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, uint64_t * b) { return my_snprintf(emu, buff, s, fmt, b); }
+#else
 EXPORT int my___snprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, uint64_t * b) __attribute__((alias("my_snprintf")));
+#endif
 EXPORT int my___snprintf_chk(x64emu_t* emu, void* buff, size_t s, int flags, size_t maxlen, void * fmt, uint64_t * b)
 {
     (void)flags; (void)maxlen;
@@ -875,7 +913,11 @@ EXPORT int my_asprintf(x64emu_t* emu, void** buff, void * fmt, uint64_t * b) {
     PREPARE_VALIST;
     return vasprintf((char**)buff, (char*)fmt, VARARGS);
 }
+#if defined(__APPLE__)
+EXPORT int my___asprintf(x64emu_t* emu, void** buff, void * fmt, uint64_t * b) { return my_asprintf(emu, buff, fmt, b); }
+#else
 EXPORT int my___asprintf(x64emu_t* emu, void** buff, void * fmt, uint64_t * b) __attribute__((alias("my_asprintf")));
+#endif
 
 EXPORT int my_vasprintf(x64emu_t* emu, char** buff, void* fmt, x64_va_list_t b) {
     (void)emu;
@@ -898,7 +940,11 @@ EXPORT int my_vsprintf(x64emu_t* emu, void* buff,  void * fmt, x64_va_list_t b)
     #endif
     return vsprintf(buff, fmt, VARARGS);
 }
+#if defined(__APPLE__)
+EXPORT int my___vsprintf_chk(x64emu_t* emu, void* buff, void * fmt, x64_va_list_t b) { return my_vsprintf(emu, buff, fmt, b); }
+#else
 EXPORT int my___vsprintf_chk(x64emu_t* emu, void* buff, void * fmt, x64_va_list_t b) __attribute__((alias("my_vsprintf")));
+#endif
 
 EXPORT int my_scanf(x64emu_t* emu, void* fmt, uint64_t* b)
 {
@@ -932,7 +978,11 @@ EXPORT int my_vsscanf(x64emu_t* emu, void* stream, void* fmt, x64_va_list_t b)
     return vsscanf(stream, fmt, VARARGS);
 }
 
+#if defined(__APPLE__)
+EXPORT int my___vsscanf(x64emu_t* emu, void* stream, void* fmt, void* b) { return my_vsscanf(emu, stream, fmt, b); }
+#else
 EXPORT int my___vsscanf(x64emu_t* emu, void* stream, void* fmt, void* b) __attribute__((alias("my_vsscanf")));
+#endif
 
 EXPORT int my_vfwscanf(x64emu_t* emu, void* F, void* fmt, x64_va_list_t b)
 {
@@ -997,11 +1047,19 @@ EXPORT int my_vscanf(x64emu_t* emu, void* fmt, x64_va_list_t b)
     return vscanf(fmt, VARARGS);
 }
 
+#if defined(__APPLE__)
+EXPORT int my__IO_vfscanf(x64emu_t* emu, void* stream, void* fmt, void* b) { return my_vfscanf(emu, stream, fmt, b); }
+EXPORT int my___isoc99_vsscanf(x64emu_t* emu, void* stream, void* fmt, void* b) { return my_vsscanf(emu, stream, fmt, b); }
+EXPORT int my___isoc99_vscanf(x64emu_t* emu, void* fmt, void* b) { return my_vscanf(emu, fmt, b); }
+EXPORT int my___isoc99_vswscanf(x64emu_t* emu, void* stream, void* fmt, void* b) { return my_vswscanf(emu, stream, fmt, b); }
+EXPORT int my___isoc99_vfscanf(x64emu_t* emu, void* stream, void* fmt, void* b) { return my_vfscanf(emu, stream, fmt, b); }
+#else
 EXPORT int my__IO_vfscanf(x64emu_t* emu, void* stream, void* fmt, void* b) __attribute__((alias("my_vfscanf")));
 EXPORT int my___isoc99_vsscanf(x64emu_t* emu, void* stream, void* fmt, void* b) __attribute__((alias("my_vsscanf")));
 EXPORT int my___isoc99_vscanf(x64emu_t* emu, void* fmt, void* b) __attribute__((alias("my_vscanf")));
 EXPORT int my___isoc99_vswscanf(x64emu_t* emu, void* stream, void* fmt, void* b) __attribute__((alias("my_vswscanf")));
 EXPORT int my___isoc99_vfscanf(x64emu_t* emu, void* stream, void* fmt, void* b) __attribute__((alias("my_vfscanf")));
+#endif
 
 EXPORT int my___isoc99_fscanf(x64emu_t* emu, void* stream, void* fmt, uint64_t* b)
 {
@@ -1010,7 +1068,11 @@ EXPORT int my___isoc99_fscanf(x64emu_t* emu, void* stream, void* fmt, uint64_t*
 
   return vfscanf(stream, fmt, VARARGS);
 }
+#if defined(__APPLE__)
+EXPORT int my_fscanf(x64emu_t* emu, void* stream, void* fmt, uint64_t* b) { return my___isoc99_fscanf(emu, stream, fmt, b); }
+#else
 EXPORT int my_fscanf(x64emu_t* emu, void* stream, void* fmt, uint64_t* b) __attribute__((alias("my___isoc99_fscanf")));
+#endif
 
 EXPORT int my___isoc99_scanf(x64emu_t* emu, void* fmt, uint64_t* b)
 {
@@ -1047,7 +1109,11 @@ EXPORT int my_vsnprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_
     int r = vsnprintf(buff, s, fmt, VARARGS);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my___vsnprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) { return my_vsnprintf(emu, buff, s, fmt, b); }
+#else
 EXPORT int my___vsnprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) __attribute__((alias("my_vsnprintf")));
+#endif
 EXPORT int my___vsnprintf_chk(x64emu_t* emu, void* buff, size_t s, int flags, size_t slen, void * fmt, x64_va_list_t b) {
     (void)emu;
     #ifdef CONVERT_VALIST
@@ -1105,8 +1171,13 @@ EXPORT int my_vswprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_
     int r = vswprintf(buff, s, fmt, VARARGS);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my___vswprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) { return my_vswprintf(emu, buff, s, fmt, b); }
+EXPORT int my___vswprintf_chk(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) { return my_vswprintf(emu, buff, s, fmt, b); }
+#else
 EXPORT int my___vswprintf(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) __attribute__((alias("my_vswprintf")));
 EXPORT int my___vswprintf_chk(x64emu_t* emu, void* buff, size_t s, void * fmt, x64_va_list_t b) __attribute__((alias("my_vswprintf")));
+#endif
 
 EXPORT int my_swscanf(x64emu_t* emu, void* stream, void* fmt, uint64_t* b)
 {
@@ -1387,7 +1458,11 @@ EXPORT int my_stat(x64emu_t *emu, void* filename, void* buf)
         UnalignStat64(&st, buf);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my_stat64(x64emu_t *emu, void* filename, void* buf) { return my_stat(emu, filename, buf); }
+#else
 EXPORT int my_stat64(x64emu_t *emu, void* filename, void* buf) __attribute__((alias("my_stat")));
+#endif
 
 EXPORT int my_lstat(x64emu_t *emu, void* filename, void* buf)
 {
@@ -1398,7 +1473,11 @@ EXPORT int my_lstat(x64emu_t *emu, void* filename, void* buf)
         UnalignStat64(&st, buf);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my_lstat64(x64emu_t *emu, void* filename, void* buf) { return my_lstat(emu, filename, buf); }
+#else
 EXPORT int my_lstat64(x64emu_t *emu, void* filename, void* buf) __attribute__((alias("my_lstat")));
+#endif
 
 EXPORT int my_fstat(x64emu_t *emu, int fd, void* buf)
 {
@@ -1409,7 +1488,11 @@ EXPORT int my_fstat(x64emu_t *emu, int fd, void* buf)
         UnalignStat64(&st, buf);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my_fstat64(x64emu_t* emu, int fd, void* buf) { return my_fstat(emu, fd, buf); }
+#else
 EXPORT int my_fstat64(x64emu_t* emu, int fd, void* buf) __attribute__((alias("my_fstat")));
+#endif
 
 EXPORT int my_fstatat(x64emu_t *emu, int fd, const char* path, void* buf, int flags)
 {
@@ -1420,7 +1503,11 @@ EXPORT int my_fstatat(x64emu_t *emu, int fd, const char* path, void* buf, int fl
         UnalignStat64(&st, buf);
     return r;
 }
+#if defined(__APPLE__)
+EXPORT int my_fstatat64(x64emu_t *emu, int fd, const char* path, void* buf, int flags) { return my_fstatat(emu, fd, path, buf, flags); }
+#else
 EXPORT int my_fstatat64(x64emu_t *emu, int fd, const char* path, void* buf, int flags) __attribute__((alias("my_fstatat")));
+#endif
 
 EXPORT int my__IO_file_stat(x64emu_t* emu, void* f, void* buf)
 {
@@ -1948,7 +2035,11 @@ EXPORT int32_t my_open(x64emu_t* emu, void* pathname, int32_t flags, uint32_t mo
     int ret = open(pathname, flags, mode);
     return ret;
 }
+#if defined(__APPLE__)
+EXPORT int32_t my___open(x64emu_t* emu, void* pathname, int32_t flags, uint32_t mode) { return my_open(emu, pathname, flags, mode); }
+#else
 EXPORT int32_t my___open(x64emu_t* emu, void* pathname, int32_t flags, uint32_t mode) __attribute__((alias("my_open")));
+#endif
 
 //#ifdef DYNAREC
 //static int hasDBFromAddress(uintptr_t addr)
@@ -2145,7 +2236,11 @@ EXPORT FILE* my_fopen64(x64emu_t* emu, const char* path, const char* mode)
     }
     return fopen64(path, mode);
 }
+#if defined(__APPLE__)
+EXPORT FILE* my_fopen(x64emu_t* emu, const char* path, const char* mode) { return my_fopen64(emu, path, mode); }
+#else
 EXPORT FILE* my_fopen(x64emu_t* emu, const char* path, const char* mode) __attribute__((alias("my_fopen64")));
+#endif
 
 #if 0
 EXPORT int32_t my_ftw(x64emu_t* emu, void* pathname, void* B, int32_t nopenfd)
@@ -2227,15 +2322,23 @@ EXPORT int32_t my_glob64(x64emu_t *emu, void* pat, int32_t flags, void* errfnc,
     (void)emu;
     return glob64(pat, flags, findgloberrFct(errfnc), pglob);
 }
+#if defined(__APPLE__)
+EXPORT int32_t my_glob(x64emu_t *emu, void* pat, int32_t flags, void* errfnc, void* pglob) { return my_glob64(emu, pat, flags, errfnc, pglob); }
+#else
 EXPORT int32_t my_glob(x64emu_t *emu, void* pat, int32_t flags, void* errfnc, void* pglob) __attribute__((alias("my_glob64")));
 #endif
+#endif
 
 EXPORT int my_scandir64(x64emu_t *emu, void* dir, void* namelist, void* sel, void* comp)
 {
     (void)emu;
     return scandir64(dir, namelist, findfilter64Fct(sel), findcompare64Fct(comp));
 }
+#if defined(__APPLE__)
+EXPORT int my_scandir(x64emu_t *emu, void* dir, void* namelist, void* sel, void* comp) { return my_scandir64(emu, dir, namelist, sel, comp); }
+#else
 EXPORT int my_scandir(x64emu_t *emu, void* dir, void* namelist, void* sel, void* comp) __attribute__((alias("my_scandir64")));
+#endif
 
 EXPORT int my_scandirat(x64emu_t *emu, int dirfd, void* dirp, void* namelist, void* sel, void* comp)
 {
@@ -2248,7 +2351,11 @@ EXPORT int my_ftw64(x64emu_t* emu, void* filename, void* func, int descriptors)
     (void)emu;
     return ftw64(filename, findftw64Fct(func), descriptors);
 }
+#if defined(__APPLE__)
+EXPORT int my_ftw(x64emu_t* emu, void* filename, void* func, int descriptors) { return my_ftw64(emu, filename, func, descriptors); }
+#else
 EXPORT int my_ftw(x64emu_t* emu, void* filename, void* func, int descriptors) __attribute__((alias("my_ftw64")));
+#endif
 
 EXPORT int32_t my_nftw64(x64emu_t* emu, void* pathname, void* B, int32_t nopenfd, int32_t flags)
 {
@@ -2798,7 +2905,11 @@ EXPORT int32_t my_fcntl(x64emu_t* emu, int32_t a, int32_t b, void* c)
 
     return ret;
 }
+#if defined(__APPLE__)
+EXPORT int32_t my___fcntl(x64emu_t* emu, int32_t a, int32_t b, void* c) { return my_fcntl(emu, a, b, c); }
+#else
 EXPORT int32_t my___fcntl(x64emu_t* emu, int32_t a, int32_t b, void* c) __attribute__((alias("my_fcntl")));
+#endif
 
 #if 0
 EXPORT int32_t my_preadv64(x64emu_t* emu, int32_t fd, void* v, int32_t c, int64_t o)
@@ -3054,7 +3165,11 @@ EXPORT void* my_mmap64(x64emu_t* emu, void *addr, size_t length, int prot, int f
     errno = e;  // preserve errno
     return ret;
 }
+#if defined(__APPLE__)
+EXPORT void* my_mmap(x64emu_t* emu, void *addr, size_t length, int prot, int flags, int fd, ssize_t offset) { return my_mmap64(emu, addr, length, prot, flags, fd, offset); }
+#else
 EXPORT void* my_mmap(x64emu_t* emu, void *addr, size_t length, int prot, int flags, int fd, ssize_t offset) __attribute__((alias("my_mmap64")));
+#endif
 
 EXPORT void* my_mremap(x64emu_t* emu, void* old_addr, size_t old_size, size_t new_size, int flags, void* new_addr)
 {
@@ -3799,7 +3914,11 @@ EXPORT void my_exit(x64emu_t* emu, int code)
     exit(code);
 }
 
+#if defined(__APPLE__)
+EXPORT void my__exit(x64emu_t* emu, int code) { my_exit(emu, code); }
+#else
 EXPORT void my__exit(x64emu_t* emu, int code) __attribute__((alias("my_exit")));
+#endif
 
 EXPORT int my_prctl(x64emu_t* emu, int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)
 {
@@ -3834,7 +3953,11 @@ EXPORT long my_sysconf(x64emu_t* emu, int what) {
     }
     return sysconf(what);
 }
+#if defined(__APPLE__)
+EXPORT long my___sysconf(x64emu_t* emu, int what) { return my_sysconf(emu, what); }
+#else
 EXPORT long my___sysconf(x64emu_t* emu, int what) __attribute__((alias("my_sysconf")));
+#endif
 
 EXPORT char* my___progname = NULL;
 EXPORT char* my___progname_full = NULL;
diff --git a/src/wrapped/wrappedlibdl.c b/src/wrapped/wrappedlibdl.c
index dd40a1aa..70230b0e 100644
--- a/src/wrapped/wrappedlibdl.c
+++ b/src/wrapped/wrappedlibdl.c
@@ -4,7 +4,9 @@
 #include <string.h>
 #include <dlfcn.h>
 #include <elf.h>
+#if !defined(__APPLE__)
 #include <link.h>
+#endif
 
 #include "wrappedlibs.h"
 
@@ -478,14 +480,12 @@ int my_dlclose(x64emu_t* emu, void *handle)
         DecRefCount(&dl->dllibs[nlib].lib, emu);
     return 0;
 }
-#ifdef ANDROID
 #ifndef RTLD_DL_SYMENT
 #define RTLD_DL_SYMENT 1
 #endif
 #ifndef RTLD_DL_LINKMAP
 #define RTLD_DL_LINKMAP 2
 #endif
-#endif
 
 int my_dladdr1(x64emu_t* emu, void *addr, void *i, void** extra_info, int flags)
 {
@@ -644,7 +644,7 @@ typedef struct my_dl_find_object_s {
     uint64_t    dlfo_flags;
     void*       dlfo_map_start;
     void*       dlfo_map_end;
-    struct link_map *dlf_link_map;
+    linkmap_t*  dlf_link_map;
     void*       dlfo_eh_frame;
     // other stuff...
 } my_dl_find_object_t;
@@ -661,7 +661,7 @@ EXPORT int my__dl_find_object(x64emu_t* emu, void* addr, my_dl_find_object_t* re
         result->dlfo_map_end = (void*)(start+sz-1);
         result->dlfo_eh_frame = (void*)(h->ehframehdr+h->delta);
         result->dlfo_flags = 0;   // unused it seems
-        result->dlf_link_map = (struct link_map *)getLinkMapElf(h);
+        result->dlf_link_map = getLinkMapElf(h);
         return 0;
     }
     return -1;
diff --git a/src/wrapped/wrappedlibgl.c b/src/wrapped/wrappedlibgl.c
index 8f854e58..1504fbbf 100644
--- a/src/wrapped/wrappedlibgl.c
+++ b/src/wrapped/wrappedlibgl.c
@@ -30,7 +30,14 @@ EXPORT void* my_glXGetProcAddress(x64emu_t* emu, void* name)
     const char* rname = (const char*)name;
     return getGLProcAddress(emu, my_lib->w.priv, rname);
 }
+#if defined(__APPLE__)
+EXPORT void* my_glXGetProcAddressARB(x64emu_t* emu, void* name)
+{
+    return my_glXGetProcAddress(emu, name);
+}
+#else
 EXPORT void* my_glXGetProcAddressARB(x64emu_t* emu, void* name) __attribute__((alias("my_glXGetProcAddress")));
+#endif
 
 typedef int  (*iFi_t)(int);
 typedef void (*vFpp_t)(void*, void*);
diff --git a/src/wrapped/wrappedlibm.c b/src/wrapped/wrappedlibm.c
index 8a7273ec..abc1766f 100644
--- a/src/wrapped/wrappedlibm.c
+++ b/src/wrapped/wrappedlibm.c
@@ -196,7 +196,7 @@ EXPORT float my_nexttowardf(x64emu_t* emu, float val, double to)
 }
 #endif
 
-#ifdef ANDROID
+#if defined(ANDROID) || defined(__APPLE__)
 double my_pow10(double a) { return pow(10.0, a);}
 float my_pow10f(float a) { return powf(10.0f, a);}
 long double my_pow10l(long double a) { return powl(10.0, a);}
diff --git a/src/wrapped/wrappedlibpthread.c b/src/wrapped/wrappedlibpthread.c
index 1effff50..485f5555 100644
--- a/src/wrapped/wrappedlibpthread.c
+++ b/src/wrapped/wrappedlibpthread.c
@@ -54,7 +54,14 @@ EXPORT int32_t my_pthread_atfork(x64emu_t *emu, void* prepare, void* parent, voi
     
     return 0;
 }
+#if defined(__APPLE__)
+EXPORT int32_t my___pthread_atfork(x64emu_t *emu, void* prepare, void* parent, void* child)
+{
+    return my_pthread_atfork(emu, prepare, parent, child);
+}
+#else
 EXPORT int32_t my___pthread_atfork(x64emu_t *emu, void* prepare, void* parent, void* child) __attribute__((alias("my_pthread_atfork")));
+#endif
 
 EXPORT void my___pthread_initialize()
 {
diff --git a/src/wrapped/wrappedlibrt.c b/src/wrapped/wrappedlibrt.c
index 438b3312..d4824c63 100644
--- a/src/wrapped/wrappedlibrt.c
+++ b/src/wrapped/wrappedlibrt.c
@@ -4,7 +4,7 @@
 #include <string.h>
 #include <dlfcn.h>
 #include <signal.h>
-#ifndef ANDROID
+#if !defined(ANDROID) && !defined(__APPLE__)
 #include <aio.h>
 #else
 #include <errno.h>
@@ -69,8 +69,16 @@ static void* findsigev_notifyFct(void* fct)
 
 #undef SUPER
 
-EXPORT int my_timer_create(x64emu_t* emu, uint32_t clockid, void* sevp, timer_t* timerid)
+EXPORT int my_timer_create(x64emu_t* emu, uint32_t clockid, void* sevp, void* timerid)
 {
+#if defined(__APPLE__)
+    (void)emu;
+    (void)clockid;
+    (void)sevp;
+    (void)timerid;
+    errno = ENOSYS;
+    return -1;
+#else
     (void)emu;
     struct sigevent sevent;
     memcpy(&sevent, sevp, sizeof(sevent));
@@ -79,9 +87,10 @@ EXPORT int my_timer_create(x64emu_t* emu, uint32_t clockid, void* sevp, timer_t*
         sevent.sigev_notify_function = findsigev_notifyFct(sevent.sigev_notify_function);
     }
 
-    return timer_create(clockid, &sevent, timerid);
+    return timer_create(clockid, &sevent, (timer_t*)timerid);
+#endif
 }
-#ifndef ANDROID
+#if !defined(ANDROID) && !defined(__APPLE__)
 EXPORT int my_aio_cancel(x64emu_t emu, int fd, struct aiocb* aiocbp)
 {
     if(aiocbp && aiocbp->aio_sigevent.sigev_notify == SIGEV_THREAD)
diff --git a/src/wrapped/wrappedsdl1.c b/src/wrapped/wrappedsdl1.c
index 1ffdfac0..bbe1e306 100644
--- a/src/wrapped/wrappedsdl1.c
+++ b/src/wrapped/wrappedsdl1.c
@@ -26,6 +26,16 @@ const char* sdl1Name = "libSDL-1.2.so.0";
 
 int sdl_Yes() { return 1; }
 int sdl_No() { return 0; }
+#if defined(__APPLE__)
+int EXPORT my_SDL_Has3DNow() { return sdl_No(); }
+int EXPORT my_SDL_Has3DNowExt() { return sdl_No(); }
+int EXPORT my_SDL_HasAltiVec() { return sdl_No(); }
+int EXPORT my_SDL_HasMMX() { return sdl_Yes(); }
+int EXPORT my_SDL_HasMMXExt() { return sdl_Yes(); }
+int EXPORT my_SDL_HasRDTSC() { return sdl_Yes(); }
+int EXPORT my_SDL_HasSSE() { return sdl_Yes(); }
+int EXPORT my_SDL_HasSSE2() { return sdl_Yes(); }
+#else
 int EXPORT my_SDL_Has3DNow() __attribute__((alias("sdl_No")));
 int EXPORT my_SDL_Has3DNowExt() __attribute__((alias("sdl_No")));
 int EXPORT my_SDL_HasAltiVec() __attribute__((alias("sdl_No")));
@@ -34,6 +44,7 @@ int EXPORT my_SDL_HasMMXExt() __attribute__((alias("sdl_Yes")));
 int EXPORT my_SDL_HasRDTSC() __attribute__((alias("sdl_Yes")));
 int EXPORT my_SDL_HasSSE() __attribute__((alias("sdl_Yes")));
 int EXPORT my_SDL_HasSSE2() __attribute__((alias("sdl_Yes")));
+#endif
 
 typedef struct {
   int32_t freq;
diff --git a/src/wrapped/wrappedsdl2.c b/src/wrapped/wrappedsdl2.c
index 483bb51e..72b10b56 100644
--- a/src/wrapped/wrappedsdl2.c
+++ b/src/wrapped/wrappedsdl2.c
@@ -32,6 +32,19 @@ void* my_dlsym(x64emu_t* emu, void *handle, void *symbol);
 
 static int sdl_Yes() { return 1;}
 static int sdl_No() { return 0;}
+#if defined(__APPLE__)
+int EXPORT my2_SDL_Has3DNow(void) { return sdl_No(); }
+int EXPORT my2_SDL_Has3DNowExt(void) { return sdl_No(); }
+int EXPORT my2_SDL_HasAltiVec(void) { return sdl_No(); }
+int EXPORT my2_SDL_HasMMX(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasMMXExt(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasNEON(void) { return sdl_No(); }   // No neon in x86_64 ;)
+int EXPORT my2_SDL_HasRDTSC(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasSSE(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasSSE2(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasSSE3(void) { return sdl_Yes(); }
+int EXPORT my2_SDL_HasSSE41(void) { return sdl_Yes(); }
+#else
 int EXPORT my2_SDL_Has3DNow(void) __attribute__((alias("sdl_No")));
 int EXPORT my2_SDL_Has3DNowExt(void) __attribute__((alias("sdl_No")));
 int EXPORT my2_SDL_HasAltiVec(void) __attribute__((alias("sdl_No")));
@@ -43,6 +56,7 @@ int EXPORT my2_SDL_HasSSE(void) __attribute__((alias("sdl_Yes")));
 int EXPORT my2_SDL_HasSSE2(void) __attribute__((alias("sdl_Yes")));
 int EXPORT my2_SDL_HasSSE3(void) __attribute__((alias("sdl_Yes")));
 int EXPORT my2_SDL_HasSSE41(void) __attribute__((alias("sdl_Yes")));
+#endif
 int EXPORT my2_SDL_HasSSE42(void) {
     return BOX64ENV(sse42)?1:0;
 }
@@ -52,7 +66,11 @@ int EXPORT my2_SDL_HasAVX(void) {
 int EXPORT my2_SDL_HasAVX2(void) {
     return BOX64ENV(avx2)?1:0;
 }
+#if defined(__APPLE__)
+int EXPORT my2_SDL_HasAVX512F(void) { return sdl_No(); }
+#else
 int EXPORT my2_SDL_HasAVX512F(void) __attribute__((alias("sdl_No")));
+#endif
 
 typedef struct {
   int32_t freq;
